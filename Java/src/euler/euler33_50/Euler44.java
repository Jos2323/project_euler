//Euler Problem 44 (http://projecteuler.net/problem=44)

/* Problem:	
	Pentagon numbers

Pentagonal numbers are generated by the formula, Pn=n(3n-1)/2. The first ten pentagonal numbers are:
1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 - 22 = 48, is not pentagonal.
Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal 
and D = |Pk - Pj| is minimised; what is the value of D?



*/

/* Lösung (Nr. 38070, 2016/05/07):

	5482660

*/


// Erklärung siehe unterhalb des Programms

//

package euler.euler33_50;

import java.util.Arrays;

public class Euler44 {
	
	public static void main(String[] args) {

		long timer = System.currentTimeMillis();

		int solution = 0;
		
		int len = 10_000;
		
		int[] pent = new int[len];
		
		pent[0] = 1;
		for (int i = 1; i < len; i++)
		{
			
			pent[i] = pent[i-1]+3*(i+1)-2;
			
		}
		
		int candSum;
		int candDiff;
		
		for (int i = 0; i < len; i++)
		{
			for (int j = 0; j < i; j++)
			{
//				candSum = pent[i]+pent[j];
//				if (Arrays.binarySearch(pent, candSum) >= 0)
				candDiff = pent[i] - pent[j];
				if (Arrays.binarySearch(pent, candDiff) >= 0 && ((solution == 0 || (solution > 0) && (candDiff < solution) )))
				{
//					candDiff = pent[i] - pent[j];
//					if (Arrays.binarySearch(pent, candDiff) >= 0)
					candSum = pent[i]+pent[j];
					if (Arrays.binarySearch(pent, candSum) >= 0)
					{
						System.out.println(pent[i] + " " + pent[j] + " " + candSum + " " + candDiff);
						
						if (solution == 0 || (solution > 0) && (candDiff < solution) )
						{
							solution = candDiff;
							System.out.println("New lowest difference: " + candDiff);
						}
					}
				}
			}
			
			if (solution > 0 && solution < pent[i])
			{
				System.out.println("Break at " + pent[i]);
				break;
			}	
		}

		System.out.println("Result: " + solution);		
		
		System.out.println("Elapsed time: " + (System.currentTimeMillis() - timer) + "ms");	
	
	}
	
	

}






/* Erklärung:
	1. Grundüberlegungen:
		- Pentagonale Zahlen haben mit jedem Schritt ein groesseren Abstand. Hierueber laesst sich eine Obergrenze finden.
		- n(3n-1)/2 - (n-1)(3(n-1)-1)/2 = (3n^2 - n - 3(n-1)^2 - (n-1 * (-1) ) / 2 = (3n^2 - (3n^2 - 6n + 3) - n + (n-1) ) / 2 =  (6n - 4) / 2 = 3n-2 
			-> 3n-2 ist der Unterschied von P_n-1 zu P_n
		- n(3n-1)/2 + m(3m-1)/2 = (3 (n^2 + m^2) - n - m) / 2 
			->  Finde k mit k(3k-1) = 3k^2 - k = 3(n^2+m^2) - (n+m) <=> 3 (k^2 - (n^2+m^2)) = k - (n+m)
			und Finde j mit j(3j-1) = 3j^2 - j = 3(n^2-m^2) - (n-m) <=> 3 (j^2 - (n^2-m^2)) = j - (n-m)
		- Es gilt: Wenn man alle Summen von unten aus hochlaufend testet, so faengt man auch gleich die Differenzen mit ab
	2. Brute Force Prinzip:
		a) Durchlaufe die Pentagonalen Zahlen (also addiere jeweils 3n-2)
		b) Fuer jede neue Zahl, pruefe ob die Differenz eine Pentagonzahl ist und ob diese kleiner als die bisherige Loesung ist
		c) Pruefe, ob die Summe eine Pentagonale Zahl ist
		d) Stoppe, sobald 3n-2 groesser als die gefundene Loesung ist
	3. Optimierungen:
		- bei b) Speichere alle Pentagonalzahlen in einer List und speichere weiter alle Summen in einer Kandidatenliste.
		- Pruefe, welche Elemente aus der Kandidatenliste wieder Pentagonal sind
		- Wenn ein Kandidat Pentagonal ist, so bilde die Summen vom Kandidat mit seinen beiden Summanden
		- Wenn eine dieser Summen Pentagonal ist, so ist eine Loesung gefunden
	
	4. Loesung:
		- Letztlich hat obiges nicht funktioniert
		- Loesungsweg: 
			1. Berechne alle Pentagonalzahlen bis zu einer Stelle (falls die Loesung so nicht gefunden wird, 
			   weil es nicht nach obiger Grenze abbricht, berechne bis zu einer laengeren Stell neu und fuehre erneut aus
			2. Durchlaufe fuer jedes Element alle bisherigen Summen und schaue, ob sie pentagonal sind
			3. Berechne fuer die pentagonalen Summen, ob auch die Differenz pentagonal ist
			 
		
	5. Im Folgenden der Fehlversuch fuer obige Ueberlegung:
	
	//		int num = 1;
//		int counter = 2;
//		
//		List<Integer> pent = new ArrayList<Integer>();
//		List<int[]> cand = new ArrayList<int[]>();
//		List<int[]> toDelete = new ArrayList<int[]>();
//		
//		pent.add(num);
//		
//		while(true)
//		{
//			
//			num += 3*counter - 2;
//			
//			
//			
//			
//			if (solution > 0 && (3*counter-2) > solution)
//				break;
//			
//			counter++;
//			
//			
//			for (Integer onePent : pent)
//			{
//				int[] oneCand = new int[]{onePent,num,onePent+num,2*num+onePent,num+2*onePent};
//				cand.add(oneCand);
//			}
//			
//			pent.add(num);
//			
//			for (int[] oneCandTest : cand)
//			{
//				if (solution > 0 && oneCandTest[1] > solution)
//				{
//					toDelete.add(oneCandTest);
//					continue;
//				}
//				
//				if (oneCandTest[3] <= Collections.max(pent))
//				{
//					boolean sol1, sol2;
//					boolean test1 = pent.contains(oneCandTest[2]);
//					boolean test2 = pent.contains(oneCandTest[4]);
//					boolean test3 = pent.contains(oneCandTest[3]);
//					System.out.println(oneCandTest[2] + " " + test1 + ", " + oneCandTest[4] + " " + test2 + ", " + oneCandTest[3] +  " " + test3);
//					if (pent.contains(oneCandTest[2]) && ((sol1 = pent.contains(oneCandTest[4])) || (sol2 = pent.contains(oneCandTest[3])) ) )
//					{
//						int posSol = sol1 ? oneCandTest[0] : oneCandTest[1]; 
//						if ( (solution == 0) || ( (solution > 0) && (posSol < solution) ) )
//						{
//							solution = posSol; 
//							System.out.println("Found new smallest candidate: " + posSol + 
//								" Numbers: " + oneCandTest[2] + " , " + (sol1 ? oneCandTest[4] : oneCandTest[3]));
//						}
//
//					}
//					toDelete.add(oneCandTest);
//				}
//			}
//			
//			cand.removeAll(toDelete);
//			
//			if (num > 1000)
//				break;
					
				
//				if (solution > 0 && oneCandTest[2] > solution)
//				{
//					toDelete.add(oneCandTest);
//					continue;
//				}
//				
//				if (oneCandTest[3] <= Collections.max(pent))
//				{
//					boolean sol1, sol2;
//					if (pent.contains(oneCandTest[2]) && ((sol1 = pent.contains(oneCandTest[4])) || (sol2 = pent.contains(oneCandTest[3])) ) )
//					{
//						if (solution == 0)
//							solution = oneCandTest[2];  
//						else
//							if (oneCandTest[2] < solution)
//							{
//								solution = oneCandTest[2];
//
//								System.out.println("Found new smallest candidate: " + oneCandTest[2] + 
//										" Numbers: " + (sol1 ? );
//							}
//							
//								
//							
//							
//					}
//						
//				}
//				
//			}
//			
//			
//
//		}
		
*/
