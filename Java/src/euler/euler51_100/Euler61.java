//Euler Problem 61 (http://projecteuler.net/problem=61 )

/* Problem:	
	Cyclical figurate numbers

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers 
and are generated by the following formulae:

Triangle	 	P3,n=n(n+1)/2	 	1, 3,  6, 10, 15, ...
Square	 		P4,n=n2	 			1, 4,  9, 16, 25, ...
Pentagonal	 	P5,n=n(3n-1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	P6,n=n(2n-1)	 	1, 6, 15, 28, 45, ...
Heptagonal	 	P7,n=n(5n-3)/2	 	1, 7, 18, 34, 55, ...
Octagonal	 	P8,n=n(3n-2)	 	1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
1. The set is cyclic, in that the last two digits of each number is the first two digits of the next number 
   (including the last number with the first).
2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), 
   is represented by a different number in the set.
3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: 
triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.



*/

/* Lösung (Nr. 19355, 2017/10/15):

	28684 (1281->8128->2882->8256->5625->2512)
	       oct   hex   pent  tri   sqr   hept

*/


// Erklärung siehe unterhalb des Programms

//

package euler.euler51_100;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Euler61 {

	static Map<Integer,List<int[]>> polys;
	
	public static void main(String[] args) {
		
		long timer = System.currentTimeMillis();
		
		int solution = 0;
		
		// polySet8 has all polygonal numbers for 8
		List<Integer> polySet8 = new ArrayList<>();
		// polys has all polygonal numbers (3-8), distributed into brackets corresponding to the first two digits 
		polys = createPolys(8,polySet8);

		List<Integer> used;
		
		int[] candSet;
		
		
		for (Integer poly8 : polySet8) {
			candSet = new int[6];
			used = new ArrayList<>();
			candSet[0] = poly8;
			used.add(8);
			if (getNext(0,candSet,used)) {
				for (int candVal : candSet) {
					solution += candVal;
					System.out.println(candVal);
				}
			}
		}
		
			
		System.out.println("Result: " + solution);	

		System.out.println("Elapsed time: " + (System.currentTimeMillis() - timer) + "ms");	
	
	}
	
	static boolean getNext(int index, int[] vals, List<Integer> used) {
		int poly = vals[index];
		List<int[]> cands = polys.get(poly%100 * 100);
		boolean solFound = false;
		if (cands != null) {
			for (int[] cand : cands) {
				if (index == 5) {
					if (cand[0] == vals[0])
						return true;
					}
				else {
					if (!used.contains(cand[1])) {
						vals[index+1] = cand[0];
						used.add(cand[1]);
						solFound = getNext(index+1,vals,used);
					}
				}
			}
		}
		if (solFound)
			return true;
		else {
			vals[index] = 0;
			used.remove(index);
		}
		return false;
	}
	

	private static Map<Integer,List<int[]>> createPolys(int retBase, List<Integer> retList) {
		Map<Integer,List<int[]>> retVal = new HashMap<>();

		for (int i = 0; i < 100; i++) {
			int val = 1000 + i*100;
			List<int[]> tmp = new ArrayList<int[]>();
			retVal.put(val, tmp);
		}
		
		for (int base = 3; base < 9; base++) {
			List<Integer> polySet = createPolySet(base);
			for (Integer i : polySet) {
				int[] poly = new int[]{i,base};
				int ind = (i/100) * 100;
				retVal.get(ind).add(poly);
				if (base == retBase)
					retList.add(i);
			}
		}
		
		return retVal;
	}


	private static List<Integer> createPolySet(int base) {
		List<Integer> retVal = new ArrayList<>();
		int i = 0;
		int add = 1;
		while (i < 10_000) {
			if (i > 999)
				retVal.add(i);
			i += add;
			add += (base-2);
		}
		return retVal;
	}
	
}


/* Erklärung:
	1. Grundüberlegungen:
		- die Hexagonalen Zahlen sind auch immer Triangle-Zahlen
	2. Brute Force Prinzip:
		a) baue 100 Listen mit den polygonalen Zahlen zwischen 1000-9999 aufgeteilt auf ihre ersten zwei Ziffern
		b) beginne mit den Octogonal-Zahlen
		c) nehme letzte zwei Ziffern und suche die zugehoerige Liste aus a) 
		d) wenn Zahl noch nicht verwendete Polygonalbasis hat, teste weiter
		e) schaue am Ende, ob die letzten beiden Ziffern mit den ersten beiden der ersten Zahl uebereinstimmen
	3. Optimierungen: 
		- 
	4. Problematik:
		- 
		

*/
